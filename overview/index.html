<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link rel="stylesheet" href="https://tsahara.github.io/r7rs/css/r7rs.css">
    <title>Overview of Scheme</title>
  </head>
  <body>
    <div style="margin-top: 20px;" />


<div>
  <nav style="width: 220px; float: left; position: fixed;">
    <div class="sidebar">
  <div style="text-align:center; font-size: 300%;">
    <a href="https://tsahara.github.io/r7rs/">R7RS</a>
  </div>

  
  <ul>
    <li><a href="/r7rs/summary/">Summary</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/intro/">Introduction</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/overview/">Overview of Scheme</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/lex/">Lexical conventions</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/basic/">Basic concepts</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/expr/">Expressions</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/prog/">Program structure</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/procs/">Standard procedures</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/formal/">Formal syntax and semantics</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/stdlib/">Standard Libraries</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/features/">Standard Feature Identifiers</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/changes/">Language changes</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/additional/">Additional material</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/example/">Example</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/ref/">References</a></li>
  </ul>
  
</div>

  </nav>

  <article style="margin-left: 240px;">
    

<p>% 1. Structure of the language</p>

<h1 id="1-overview-of-scheme">1. Overview of Scheme</h1>

<h2 id="1-1-semantics">1.1. Semantics</h2>

<a id="semanticsection"></a>


<p>This section gives an overview of Scheme&rsquo;s semantics.  A
detailed informal semantics is the subject of
chapters~\ref{basicchapter} through 6.  For reference
purposes, section~\ref{formalsemanticssection} provides a formal
semantics of Scheme.</p>

<p>Scheme is a statically scoped programming
language.  Each use of a variable is associated with a lexically
apparent binding of that variable.</p>

<p>Scheme is a dynamically typed language.  Types
are associated with values (also called objects\mainindex{object}) rather than
with variables.
Statically typed languages, by contrast, associate types with
variables and expressions as well as with values.</p>

<p>All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.
No Scheme object is ever destroyed.  The reason that
implementations of Scheme do not (usually!) run out of storage is that
they are permitted to reclaim the storage occupied by an object if
they can prove that the object cannot possibly matter to any future
computation.</p>

<p>Implementations of Scheme are required to be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure.  Thus with a properly tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call
mechanics, so that special iteration constructs are useful only as
syntactic sugar.  See section~\ref{proper tail recursion}.</p>

<p>Scheme procedures are objects in their own right.  Procedures can be
created dynamically, stored in data structures, returned as results of
procedures, and so on.</p>

<p>One distinguishing feature of Scheme is that continuations, which
in most other languages only operate behind the scenes, also have
&ldquo;first-class&rdquo; status.  Continuations are useful for implementing a
wide variety of advanced control constructs, including non-local exits,
backtracking, and coroutines.  See section~\ref{continuations}.</p>

<p>Arguments to Scheme procedures are always passed by value, which
means that the actual argument expressions are evaluated before the
procedure gains control, regardless of whether the procedure needs the
result of the evaluation.</p>

<p>Scheme&rsquo;s model of arithmetic is designed to remain as independent as
possible of the particular ways in which numbers are represented within a
computer. In Scheme, every integer is a rational number, every rational is a
real, and every real is a complex number.  Thus the distinction between integer
and real arithmetic, so important to many programming languages, does not
appear in Scheme.  In its place is a distinction between exact arithmetic,
which corresponds to the mathematical ideal, and inexact arithmetic on
approximations.  Exact arithmetic is not limited to integers.</p>

<h2 id="1-2-syntax">1.2. Syntax</h2>

<p>Scheme, like most dialects of Lisp, employs a fully parenthesized prefix
notation for programs and other data; the grammar of Scheme generates a
sublanguage of the language used for data.  An important
consequence of this simple, uniform representation is that
Scheme programs and data can easily be treated uniformly by other Scheme programs.
For example, the <code>eval</code> procedure evaluates a Scheme program expressed
as data.</p>

<p>The <code>read</code> procedure performs syntactic as well as lexical decomposition of
the data it reads.  The <code>read</code> procedure parses its input as data
(section~\ref{datumsyntax}), not as program.</p>

<p>The formal syntax of Scheme is described in section~\ref{BNF}.</p>

<h2 id="1-3-notation-and-terminology">1.3. Notation and terminology</h2>

<h3 id="1-3-1-base-and-optional-features">1.3.1. Base and optional features</h3>

<a id="qualifiers"></a>


<p>Every identifier defined in this report appears in one or more of several
\defining{libraries}.  Identifiers defined in the \defining{base library}
are not marked specially in the body of the report.
This library includes the core syntax of Scheme
and generally useful procedures that manipulate data.  For example, the
variable <code>abs</code> is bound to a
procedure of one argument that computes the absolute value of a
number, and the variable <code>+</code> is bound to a procedure that computes
sums.  The full list
all the standard libraries and the identifiers they export is given in
Appendix A.</p>

<p>All implementations of Scheme:
\begin{itemize}</p>

<p>\item Must provide the base library and all the identifiers
exported from it.</p>

<p>\item May provide or omit the other
libraries given in this report, but each library must either be provided
in its entirety, exporting no additional identifiers, or else omitted
altogether.</p>

<p>\item May provide other libraries not described in this report.</p>

<p>\item May also extend the function of any identifier in this
report, provided the extensions are not in conflict with the language
reported here.</p>

<p>\item Must support portable
code by providing a mode of operation in which the lexical syntax does
not conflict with the lexical syntax described in this report.
\end{itemize}</p>

<h3 id="1-3-2-error-situations-and-unspecified-behavior">1.3.2. Error situations and unspecified behavior</h3>

<a id="errorsituations"></a>


<p>\mainindex{error}
When speaking of an error situation, this report uses the phrase &ldquo;an
error is signaled&rdquo; to indicate that implementations must detect and
report the error.
An error is signaled by raising a non-continuable exception, as if by
the procedure <code>raise</code> as described in section~\ref{exceptionsection}.  The object raised is implementation-dependent
and need not be distinct from objects previously used for the same purpose.
In addition to errors signaled in situations described in this
report, programmers can signal their own errors and handle signaled errors.</p>

<p>The phrase &ldquo;an error that satisfies {\em predicate} is signaled&rdquo; means that an error is
signaled as above.  Furthermore, if the object that is signaled is
passed to the specified predicate (such as <code>file-error?</code> or {\cf
read-error?}), the predicate returns \schtrue{}.</p>

<p>If such wording does not appear in the discussion of
an error, then implementations are not required to detect or report the
error, though they are encouraged to do so.
Such a situation is sometimes, but not always, referred to with the phrase
&ldquo;an error.&rdquo;
In such a situation, an implementation may or may not signal an error;
if it does signal an error, the object that is signaled may or may not
satisfy the predicates <code>error-object?</code>, <code>file-error?</code>, or
<code>read-error?</code>.
Alternatively, implementations may provide non-portable extensions.</p>

<p>For example, it is an error for a procedure to be passed an argument of a type that
the procedure is not explicitly specified to handle, even though such
domain errors are seldom mentioned in this report.  Implementations may
signal an error,
extend a procedure&rsquo;s domain of definition to include such arguments,
or fail catastrophically.</p>

<p>This report uses the phrase &ldquo;may report a violation of an
implementation restriction&rdquo; to indicate circumstances under which an
implementation is permitted to report that it is unable to continue
execution of a correct program because of some restriction imposed by the
implementation.  Implementation restrictions are discouraged,
but implementations are encouraged to report violations of implementation
restrictions.\mainindex{implementation restriction}</p>

<p>For example, an implementation may report a violation of an
implementation restriction if it does not have enough storage to run a
program,
or if an arithmetic operation would produce an exact number that is
too large for the implementation to represent.</p>

<p>If the value of an expression is said to be &ldquo;unspecified,&rdquo; then
the expression must evaluate to some object without signaling an error,
but the value depends on the implementation; this report explicitly does
not say what value is returned. \mainindex{unspecified}</p>

<p>Finally, the words and phrases &ldquo;must,&rdquo; &ldquo;must not,&rdquo; &ldquo;shall,&rdquo;
&ldquo;shall not,&rdquo; &ldquo;should,&rdquo; &ldquo;should not,&rdquo; &ldquo;may,&rdquo; &ldquo;required,&rdquo;
&ldquo;recommended,&rdquo; and &ldquo;optional,&rdquo; although not capitalized in this
report, are to be interpreted as described in RFC~2119~\cite{rfc2119}.
They are used only with reference to implementer or implementation behavior,
not with reference to programmer or program behavior.</p>

<h3 id="1-3-3-entry-format">1.3.3. Entry format</h3>

<p>Chapters 4 and 6 are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
procedure.  An entry begins with one or more header lines of the form</p>

<p>\noindent\pproto{\var{template}}{\var{category}}\unpenalty</p>

<p>for identifiers in the base library, or</p>

<p>\noindent\pproto{\var{template}}{\var{name} library \var{category}}\unpenalty</p>

<p>where \var{name} is the short name of a library
as defined in Appendix A.</p>

<p>If \var{category} is &ldquo;\exprtype,&rdquo; the entry describes an expression
type, and the template gives the syntax of the expression type.
Components of expressions are designated by syntactic variables, which
are written using angle brackets, for example \hyper{expression} and
\hyper{variable}.  Syntactic variables are intended to denote segments of
program text; for example, \hyper{expression} stands for any string of
characters which is a syntactically valid expression.  The notation
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
indicates zero or more occurrences of a \hyper{thing}, and
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
indicates one or more occurrences of a \hyper{thing}.</p>

<p>If \var{category} is &ldquo;auxiliary syntax,&rdquo; then the entry describes a
syntax binding that occurs only as part of specific surrounding
expressions. Any use as an independent syntactic construct or
variable is an error.</p>

<p>If \var{category} is &ldquo;procedure,&rdquo; then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Argument
names in the template are \var{italicized}.  Thus the header line</p>

<p>\noindent\pproto{(vector-ref \var{vector} \var{k})}{procedure}\unpenalty</p>

<p>indicates that the procedure bound to the {\tt vector-ref} variable takes
two arguments, a vector \var{vector} and an exact non-negative integer
\var{k} (see below).  The header lines</p>

<p>\noindent
\pproto{(make-vector \var{k})}{procedure}
\pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty</p>

<p>indicate that the {\tt make-vector} procedure must be defined to take
either one or two arguments.</p>

<p><a id="typeconventions"></a>

It is an error for a procedure to be presented with an argument that it
is not specified to handle.  For succinctness, we follow the convention
that if an argument name is also the name of a type listed in
section~\ref{disjointness}, then it is an error if that argument is not of the named type.
For example, the header line for {\tt vector-ref} given above dictates that the
first argument to {\tt vector-ref} is a vector.  The following naming
conventions also imply type restrictions:
\newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
$$
\begin{tabular}{ll}
\vr{alist}&amp;association list (list of pairs)<br />
\vr{boolean}&amp;boolean value (\schtrue{} or \schfalse{})<br />
\vr{byte}&amp;exact integer $0 \leq byte &lt; 256$<br />
\vr{bytevector}&amp;bytevector<br />
\vr{char}&amp;character<br />
\vr{end}&amp;exact non-negative integer<br />
\foo{k}&amp;exact non-negative integer<br />
\vr{letter}&amp;alphabetic character<br />
\foo{list}&amp;list (see section~\ref{listsection})<br />
\foo{n}&amp;integer<br />
\var{obj}&amp;any object<br />
\vr{pair}&amp;pair<br />
\vr{port}&amp;port<br />
\vr{proc}&amp;procedure<br />
\foo{q}&amp;rational number<br />
\vr{start}&amp;exact non-negative integer<br />
\vr{string}&amp;string<br />
\vr{symbol}&amp;symbol<br />
\vr{thunk}&amp;zero-argument procedure<br />
\vr{vector}&amp;vector<br />
\foo{x}&amp;real number<br />
\foo{y}&amp;real number<br />
\foo{z}&amp;complex number<br />
\end{tabular}
$$</p>

<p>The names \vr{start} and \vr{end} are used as indexes into strings,
vectors, and bytevectors.  Their use implies the following:</p>

<p>\begin{itemize}</p>

<p>\item{It is an error if \var{start} is greater than \var{end}.}</p>

<p>\item{It is an error if \var{end} is greater than the length of the
string, vector, or bytevector.}</p>

<p>\item{If \var{start} is omitted, it is assumed to be zero.}</p>

<p>\item{If \var{end} is omitted, it assumed to be the length of the string,
vector, or bytevector.}</p>

<p>\item{The index \var{start} is always inclusive and the index \var{end} is always
exclusive.  As an example, consider a string.  If
\var{start} and \var{end} are the same, an empty
substring is referred to, and if \var{start} is zero and \var{end} is
the length of \var{string}, then the entire string is referred to.}</p>

<p>\end{itemize}</p>

<h3 id="1-3-4-evaluation-examples">1.3.4. Evaluation examples</h3>

<p>The symbol &ldquo;\evalsto&rdquo; used in program examples is read
&ldquo;evaluates to.&rdquo;  For example,</p>

<pre><code>(* 5 8)      \ev  40
</code></pre>

<p>means that the expression {\tt(* 5 8)} evaluates to the object {\tt 40}.
Or, more precisely:  the expression given by the sequence of characters
&ldquo;{\tt(* 5 8)}&rdquo; evaluates, in the initial environment, to an object
that can be represented externally by the sequence of characters &ldquo;{\tt
40}.&rdquo;  See section~\ref{externalreps} for a discussion of external
representations of objects.</p>

<h3 id="1-3-5-naming-conventions">1.3.5. Naming conventions</h3>

<p>By convention, \ide{?} is the final character of the names
of procedures that always return a boolean value.
Such procedures are called \defining{predicates}.
Predicates are generally understood to be side-effect free, except that they
may raise an exception when passed the wrong type of argument.</p>

<p>Similarly, \ide{!} is the final character of the names
of procedures that store values into previously
allocated locations (see section~\ref{storagemodel}).
Such procedures are called \defining{mutation procedures}.
The value returned by a mutation procedure is unspecified.</p>

<p>By convention, &ldquo;\ide{-&gt;}&rdquo; appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, <code>list-&gt;vector</code> takes a list and returns a vector whose
elements are the same as those of the list.</p>

<p>A \defining{command} is a procedure that does not return useful values
to its continuation.</p>

<p>A \defining{thunk} is a procedure that does not accept arguments.</p>

  </article>
</div>

</body>
</html>

