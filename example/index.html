<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link rel="stylesheet" href="https://tsahara.github.com/r7rs/css/r7rs.css">
    <title>Example</title>
  </head>
  <body>


<div>
  <nav style="width: 220px; float: left; position: fixed;">
    <div class="sidebar">
  <div style="text-align:center; font-size: 300%;">
    <a href="https://tsahara.github.com/r7rs/">R7RS</a>
  </div>

  
  <ul>
    <li><a href="/r7rs/summary/">Summary</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/intro/">Introduction</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/overview/">Overview of Scheme</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/lex/">Lexical conventions</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/basic/">Basic concepts</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/expr/">Expressions</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/prog/">Program structure</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/procs/">Standard procedures</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/formal/">Formal syntax and semantics</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/stdlib/">Standard Libraries</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/features/">Standard Feature Identifiers</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/changes/">Language changes</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/additional/">Additional material</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/example/">Example</a></li>
  </ul>
  
  <ul>
    <li><a href="/r7rs/ref/">References</a></li>
  </ul>
  
</div>

  </nav>

  <article style="margin-left: 240px;">
    <p>\extrapart{Example} % -<em>- Mode: Lisp; Package: SCHEME; Syntax: Common-lisp -</em>-</p>

<p>\nobreak
The procedure {\cf integrate-system} integrates the system
$$y_k^\prime = f_k(y_1, y_2, \ldots, y_n), \; k = 1, \ldots, n$$
of differential equations with the method of Runge-Kutta.</p>

<p>The parameter {\tt system-derivative} is a function that takes a system
state (a vector of values for the state variables $y_1, \ldots, y_n$)
and produces a system derivative (the values $y_1^\prime, \ldots,
y_n^\prime$).  The parameter {\tt initial-state} provides an initial
system state, and {\tt h} is an initial guess for the length of the
integration step.</p>

<p>The value returned by {\cf integrate-system} is an infinite stream of
system states.</p>

<p>\begin{schemenoindent}
(define (integrate-system system-derivative
                          initial-state
                          h)
  (let ((next (runge-kutta-4 system-derivative h)))
    (letrec ((states
              (cons initial-state
                    (delay (map-streams next
                                        states)))))
      states)))%
\end{schemenoindent}</p>

<p>The procedure {\cf runge-kutta-4} takes a function, {\tt f}, that produces a
system derivative from a system state.  It
produces a function that takes a system state and
produces a new system state.</p>

<p>\begin{schemenoindent}
(define (runge-kutta-4 f h)
  (let ((*h (scale-vector h))
        (*2 (scale-vector 2))
        (*<sup>1</sup>&frasl;<sub>2</sub> (scale-vector (/ 1 2)))
        (<em><sup>1</sup>&frasl;<sub>6</sub> (scale-vector (/ 1 6))))
    (lambda (y)
      ;; y is a system state
      (let</em> ((k0 (*h (f y)))
             (k1 (*h (f (add-vectors y (*<sup>1</sup>&frasl;<sub>2</sub> k0)))))
             (k2 (*h (f (add-vectors y (*<sup>1</sup>&frasl;<sub>2</sub> k1)))))
             (k3 (*h (f (add-vectors y k2)))))
        (add-vectors y
          (*<sup>1</sup>&frasl;<sub>6</sub> (add-vectors k0
                             (*2 k1)
                             (*2 k2)
                             k3)))))))</p>

<p>(define (elementwise f)
  (lambda vectors
    (generate-vector
     (vector-length (car vectors))
     (lambda (i)
       (apply f
              (map (lambda (v) (vector-ref  v i))
                   vectors))))))</p>

<p>(define (generate-vector size proc)
  (let ((ans (make-vector size)))
    (letrec ((loop
              (lambda (i)
                (cond ((= i size) ans)
                      (else
                       (vector-set! ans i (proc i))
                       (loop (+ i 1)))))))
      (loop 0))))</p>

<p>(define add-vectors (elementwise +))</p>

<p>(define (scale-vector s)
  (elementwise (lambda (x) (* x s))))%
\end{schemenoindent}</p>

<p>The {\cf map-streams} procedure is analogous to {\cf map}: it applies its first
argument (a procedure) to all the elements of its second argument (a
stream).</p>

<p>\begin{schemenoindent}
(define (map-streams f s)
  (cons (f (head s))
        (delay (map-streams f (tail s)))))%
\end{schemenoindent}</p>

<p>Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a promise to deliver the rest
of the stream.</p>

<p>\begin{schemenoindent}
(define head car)
(define (tail stream)
  (force (cdr stream)))%
\end{schemenoindent}</p>

<p>\bigskip
The following illustrates the use of {\cf integrate-system} in
integrating the system
$$ C {dv_C \over dt} = -i_L - {v_C \over R}$$\nobreak
$$ L {di_L \over dt} = v_C$$
which models a damped oscillator.</p>

<p>\begin{schemenoindent}
(define (damped-oscillator R L C)
  (lambda (state)
    (let ((Vc (vector-ref state 0))
          (Il (vector-ref state 1)))
      (vector (- 0 (+ (/ Vc (* R C)) (/ Il C)))
              (/ Vc L)))))</p>

<p>(define the-states
  (integrate-system
     (damped-oscillator 10000 1000 .001)
     &lsquo;#(1 0)
     .01))%
\end{schemenoindent}</p>

  </article>
</div>

</body>
</html>

